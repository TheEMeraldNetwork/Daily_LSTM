<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>E_LSTM_Forecasting – Daily Dashboard</title>
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
	<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
	<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
	<style>
		:root { --bg:#0e1116; --card:#151a22; --muted:#8a94a6; --text:#e7ecf3; --accent:#2ea3f2; --ok:#18c49c; --warn:#ffba08; --bad:#ff5c5c; }
		html,body { height:100%; margin:0; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; background:var(--bg); color:var(--text); }
		.container { max-width: 1400px; margin: 0 auto; padding: 16px 20px 32px; }
		h1 { font-size: 20px; margin: 0 0 10px; }
		.controls { display:flex; gap:12px; align-items:center; flex-wrap: wrap; margin-bottom: 14px; }
		select, input[type="text"] { background: var(--card); color: var(--text); border: 1px solid #2a3240; border-radius: 8px; padding: 8px 10px; }
		.grid { display:grid; grid-template-columns: 1fr 1fr; grid-auto-rows: minmax(320px, auto); gap: 16px; }
		.card { background: var(--card); border: 1px solid #1f2430; border-radius: 12px; padding: 12px; box-shadow: 0 0 0 1px rgba(255,255,255,0.02) inset; }
		.card h2 { font-size: 16px; margin: 0 0 8px; }
		.small { color: var(--muted); font-size: 12px; }
		.table { width: 100%; border-collapse: collapse; }
		.table th, .table td { border-bottom: 1px solid #222836; padding: 8px 10px; font-size: 13px; text-align: right; }
		.table th { color: var(--muted); font-weight: 600; text-transform: uppercase; letter-spacing: .02em; font-size: 12px; }
		.badge { display:inline-block; padding: 2px 6px; border-radius: 6px; font-size: 12px; }
		.badge.ok { background: rgba(24,196,156,.14); color: var(--ok); }
		.badge.warn { background: rgba(255,186,8,.14); color: var(--warn); }
		.badge.bad { background: rgba(255,92,92,.14); color: var(--bad); }
		.flex { display:flex; gap:10px; align-items:center; justify-content: space-between; }
		.kpi { font-weight: 700; }
		.footer { margin-top: 16px; color: var(--muted); font-size: 12px; }
		@media (max-width: 1100px) { .grid { grid-template-columns: 1fr; } }
	</style>
</head>
<body>
	<div class="container">
		<h1>Forecast10 Dashboard</h1>
		<div class="controls">
			<label>
				<span class="small">Filter symbol</span><br/>
				<input id="symbolFilter" type="text" placeholder="e.g. AAPL, MSFT (optional)" />
			</label>
			<button id="applyBtn">Apply</button>
			<span class="small" id="statusLine"></span>
		</div>

		<div class="grid">
			<div class="card">
				<div class="flex"><h2>Scatter: F10_T / C1_T vs F10_T / A1_T</h2><div class="small">T
					<select id="scatterDate"></select>
				</div></div>
				<div id="scatter" style="height:360px;"></div>
				<div class="small">Axes show % deltas. Guide lines at 0% (x,y). <span id="quadCounts"></span></div>
			</div>
			<div class="card">
				<div class="flex"><h2>Bins (latest day)</h2><div class="small">T <select id="binsDateSelect"></select> <span class="small" id="binsDate"></span></div></div>
				<table class="table" id="binsTable">
					<thead><tr><th style="text-align:left">Bin</th><th>Count</th><th>Mean F10 vs A1 (%)</th><th>Trend (7d)</th></tr></thead>
					<tbody></tbody>
				</table>
			</div>
			<div class="card" style="grid-column:1/3;">
				<div class="flex"><h2>Certified candidates (|F10/C1| ≤ 2%)</h2><div class="small">T+1 <select id="actionsDate"></select> · uses A1_(T-1)=<span id="actionsPrevLabel"></span> · <span id="certCount"></span></div></div>
				<table class="table" id="actionTable">
					<thead><tr>
						<th style="text-align:left">Symbol</th>
						<th style="text-align:left">Name</th>
						<th>F10/C1 (%)</th>
						<th>F10_T</th>
						<th>A1_(T-1)</th>
						<th>F10 / A1(T-1) (%)</th>
						<th>Sent7d</th>
						<th>Sent>0.2</th>
						<th>A1_T</th>
						<th>F10 / A1_T (%)</th>
					</tr></thead>
					<tbody></tbody>
				</table>
			</div>
		</div>

		<div class="footer">Data sources: comparison tables and bins under ../data/processed/predictions/. Degrades gracefully when files are not present.</div>
	</div>

	<script>
	// Configuration
	const PRED_DIR = './data/processed/predictions';
	const APP_DATA_DIR = './App/data'; // preferred local cache for dashboard
	const TECH_DIR = '../w_datalake/data/raw/technical'; // optional, may be missing
	const BINS = [0,2,5,10,20];
	const BIN_LABELS = ['<0%','0-2%','2-5%','5-10%','10-20%','>20%'];
    const STAGING_DIR = './data/staging'; // optional 5-stock staging
    const STAGING = { active:false, analysis_T:null, morning_Tp1:null, symbols:[] };
    let CURRENT = { scatterT:null, binsT:null, actionsTp1:null };

    const scatterDate = document.getElementById('scatterDate');
    const binsDateSelect = document.getElementById('binsDateSelect');
    const actionsDate = document.getElementById('actionsDate');
    const symbolFilter = document.getElementById('symbolFilter');
    const statusLine = document.getElementById('statusLine');
    const binsDate = document.getElementById('binsDate');
    const actionsPrevLabel = document.getElementById('actionsPrevLabel');

	function ymd(date){ const y=date.getFullYear(); const m=String(date.getMonth()+1).padStart(2,'0'); const d=String(date.getDate()).padStart(2,'0'); return `${y}${m}${d}`; }
	function addDays(date, delta){ const d=new Date(date); d.setDate(d.getDate()+delta); return d; }
	function businessPrevYmd(yyyymmdd){
		const y = Number(yyyymmdd.slice(0,4)), m = Number(yyyymmdd.slice(4,6))-1, d = Number(yyyymmdd.slice(6,8));
		const dt = new Date(y,m,d);
		do { dt.setDate(dt.getDate()-1); } while (dt.getDay()===0 || dt.getDay()===6);
		return ymd(dt);
	}

	async function headExists(url){
		try {
			const sep = url.includes('?') ? '&' : '?';
			const res = await fetch(`${url}${sep}v=${Date.now()}`, {method:'GET'});
			return res.ok;
		} catch(e){ return false; }
	}

    async function loadStagingMeta(){
        try {
            const res = await fetch(`${STAGING_DIR}/meta.json`);
            if (!res.ok) return false;
            const meta = await res.json();
            STAGING.active = true;
            STAGING.analysis_T = String(meta.analysis_T || '');
            STAGING.morning_Tp1 = String(meta.morning_T || meta.morning_T_plus_1 || '');
            STAGING.symbols = meta.symbols || [];
            return true;
        } catch(e){ return false; }
    }

	async function discoverDates(maxBack=60){
		// Build a union of dates from: meta.latest_date, comparison tables, certified files
		const set = new Set();
		try { const meta = await (await fetch(`${APP_DATA_DIR}/meta.json`)).json(); if (meta && meta.latest_date) set.add(String(meta.latest_date)); } catch(e) {}
		// scan back for comparison tables
		const today = new Date();
		for (let i=0;i<maxBack;i++){
			const d = ymd(addDays(today, -i));
			if (await headExists(`${PRED_DIR}/comparison_table_${d}.csv`)) set.add(d);
		}
		// probe for certified files (morning output)
		for (let i=0;i<7;i++){
			const d = ymd(addDays(today, -i));
			if (await headExists(`${APP_DATA_DIR}/certified_candidates_${d}.csv`)) set.add(d);
		}
		return Array.from(set).sort();
	}

	async function discoverComparisonDates(maxBack=60){
		const found = [];
		const today = new Date();
		for (let i=0;i<maxBack;i++){
			const d = ymd(addDays(today, -i));
			// Prefer App/data if present, fallback to backend predictions dir
			if (await headExists(`${APP_DATA_DIR}/comparison_table_${d}.csv`)) { found.push(d); continue; }
			if (await headExists(`${PRED_DIR}/comparison_table_${d}.csv`)) found.push(d);
		}
		return found.reverse();
	}

	async function discoverCertifiedDates(maxBack=30){
		const found = [];
		const today = new Date();
		for (let i=0;i<maxBack;i++){
			const d = ymd(addDays(today, -i));
			if (await headExists(`${APP_DATA_DIR}/certified_candidates_${d}.csv`)) found.push(d);
		}
		return found.reverse();
	}

	function mapColumns(df){
		const cols = {}; const lc = {};
		for (const c of df.meta.fields){ lc[c.toLowerCase()] = c; }
		const pick = (keys) => {
			for (const k of keys){ for (const key in lc){ if (key.includes(k)) return lc[key]; } }
			return null;
		};
		return {
			f10: pick(['forecast10_t','forecast10']),
			f1: pick(['forecast1_t','forecast1']),
			c1: pick(['consensus1_t','consensus1','consensus']),
			a1: pick(['actual_t','actual']),
			name: pick(['name','company','security'])
		};
	}

	async function loadCSV(url){
		const sep = url.includes('?') ? '&' : '?';
		const txt = await (await fetch(`${url}${sep}v=${Date.now()}`)).text();
		return await new Promise((resolve)=>{
			Papa.parse(txt, { header:true, dynamicTyping:true, skipEmptyLines:true, complete: (res)=> resolve(res) });
		});
	}

	function toNum(v){ const x = Number(v); return Number.isFinite(x) ? x : NaN; }
	function ratioToPct(r){ return Number.isFinite(r) ? (r-1)*100 : NaN; }
	function fmtPct(r, digits=1){ const v = ratioToPct(r); return Number.isFinite(v) ? `${v.toFixed(digits)}%` : 'N/A'; }
	function parseCellNumber(txt){ if (txt==null) return NaN; const s = String(txt).replace(/[%,$\s]/g,''); const n = Number(s); return Number.isFinite(n)? n : NaN; }

	function enableSorting(tableId){
		const table = document.getElementById(tableId);
		if (!table) return;
		const ths = table.querySelectorAll('thead th');
		ths.forEach((th, idx)=>{
			th.style.cursor = 'pointer';
			th.addEventListener('click', ()=>{
				const tbody = table.querySelector('tbody');
				const rows = Array.from(tbody.querySelectorAll('tr'));
            const dir = th.dataset.dir ? (th.dataset.dir === 'asc' ? 'desc' : 'asc') : 'asc';
				ths.forEach(h=> delete h.dataset.dir); th.dataset.dir = dir;
				rows.sort((a,b)=>{
					const av = a.children[idx]?.textContent || '';
					const bv = b.children[idx]?.textContent || '';
					const an = parseCellNumber(av), bn = parseCellNumber(bv);
					let cmp;
					if (Number.isFinite(an) && Number.isFinite(bn)) cmp = an - bn; else cmp = String(av).localeCompare(String(bv));
					return dir==='asc' ? cmp : -cmp;
				});
				rows.forEach(r=> tbody.appendChild(r));
			});
		});
	}

	function computeScatter(df, cols, filterSymbols){
		const x=[], y=[], text=[];
		for (const row of df.data){
			const sym = row.Symbol || row.symbol || row.SYMBOL || row.ticker || row.Ticker;
			if (filterSymbols && filterSymbols.size && (!sym || !filterSymbols.has(String(sym).toUpperCase()))) continue;
			const f10 = toNum(row[cols.f10]); const c1 = toNum(row[cols.c1]); const a1 = toNum(row[cols.a1]);
			if (!Number.isFinite(f10) || !Number.isFinite(c1) || !Number.isFinite(a1) || c1<=0 || a1<=0) continue;
			x.push(ratioToPct(f10 / c1));
			y.push(ratioToPct(f10 / a1));
			text.push(sym);
		}
		return {x,y,text};
	}

	function plotScatter(series){
    const minX = Math.min(...series.x, 0);
    const maxX = Math.max(...series.x, 0);
    const minY = Math.min(...series.y, 0);
    const maxY = Math.max(...series.y, 0);
    // Quadrant counts relative to axes (0,0)
    let q1=0,q2=0,q3=0,q4=0, onAxes=0;
    for (let i=0;i<series.x.length;i++){
        const xx = series.x[i]; const yy = series.y[i];
        if (xx===0 || yy===0) { onAxes++; continue; }
        if (xx>0 && yy>0) q1++; else if (xx<0 && yy>0) q2++; else if (xx<0 && yy<0) q3++; else if (xx>0 && yy<0) q4++;
    }
    const qc = document.getElementById('quadCounts');
    if (qc){ qc.textContent = `Q1(+/+)=${q1} · Q2(-/+)=${q2} · Q3(-/-)=${q3} · Q4(+/-)=${q4}${onAxes?` · on-axes=${onAxes}`:''}`; }
		const pad = 0.05;
		const layout = {
			margin:{l:40,r:10,t:10,b:40}, paper_bgcolor:'transparent', plot_bgcolor:'transparent',
			xaxis:{title:'F10_T / C1_T (%)', gridcolor:'#1f2430', zerolinecolor:'#2a3240', ticksuffix:'%', range:[minX*(1-pad), maxX*(1+pad)]},
			yaxis:{title:'F10_T / A1_T (%)', gridcolor:'#1f2430', zerolinecolor:'#2a3240', ticksuffix:'%', range:[minY*(1-pad), maxY*(1+pad)]},
			shapes:[
				{type:'line', x0:-5, x1:5, y0:0, y1:0, line:{color:'#444', width:1, dash:'dot'}},
				{type:'line', x0:0, x1:0, y0:-5, y1:5, line:{color:'#444', width:1, dash:'dot'}}
			],
			showlegend:false
		};
		const data = [{ type:'scattergl', mode:'markers', x:series.x, y:series.y, text:series.text, hovertemplate:'%{text}<br>x=%{x:.1f}%<br>y=%{y:.1f}%<extra></extra>', marker:{ color:'#2ea3f2', size:6, opacity:0.85 } }];
		Plotly.newPlot('scatter', data, layout, {displayModeBar:false, responsive:true});
	}

	async function loadBinsForDate(dateList, selected){
		// prefer the selected date; fall back to latest available
		const tryDates = [selected, ...dateList.slice().reverse()].filter(Boolean);
		for (const d of tryDates){
			const appUrl = `${APP_DATA_DIR}/bins_summary_${d}.csv`;
			if (await headExists(appUrl)) { const df = await loadCSV(appUrl); return { date:d, df }; }
			const url = `${PRED_DIR}/bins_summary_${d}.csv`;
			if (await headExists(url)) { const df = await loadCSV(url); return { date:d, df }; }
		}
		return null;
	}

	function mapBinsColumns(df){
		const lc = {}; for (const c of df.meta.fields){ lc[c.toLowerCase()] = c; }
		const binC = lc['bin'] || lc['bins'] || Object.values(lc).find(v=>/bin/i.test(v));
		const countC = lc['count'] || Object.values(lc).find(v=>/count/i.test(v));
		const meanC = Object.values(lc).find(v=>/mean.*f10.*a1|mean.*error|avg.*f10/i.test(v.toLowerCase())) || Object.values(lc).find(v=>/mean/i.test(v));
		const trendC = Object.values(lc).find(v=>/trend|7d/i.test(v.toLowerCase()));
		return { binC, countC, meanC, trendC };
	}

	function renderBinsTable(bins){
		const tbody = document.querySelector('#binsTable tbody');
		tbody.innerHTML = '';
		if (!bins || !bins.df || !bins.df.data || !bins.df.data.length){ binsDate.textContent=''; return; }
		const { binC, countC, meanC, trendC } = mapBinsColumns(bins.df);
		binsDate.textContent = `T=${bins.date.slice(0,4)}-${bins.date.slice(4,6)}-${bins.date.slice(6,8)}`;
		for (const r of bins.df.data){
			const tr = document.createElement('tr');
			const td0 = document.createElement('td'); td0.style.textAlign='left'; td0.textContent = r[binC]; tr.appendChild(td0);
			const td1 = document.createElement('td'); td1.textContent = toNum(r[countC])?.toLocaleString('en-US'); tr.appendChild(td1);
			const td2 = document.createElement('td'); td2.textContent = Number.isFinite(toNum(r[meanC])) ? `${toNum(r[meanC]).toFixed(1)}%` : 'N/A'; tr.appendChild(td2);
			const td3 = document.createElement('td'); td3.textContent = Number.isFinite(toNum(r[trendC])) ? `${toNum(r[trendC]).toFixed(1)}%` : 'N/A'; tr.appendChild(td3);
			tbody.appendChild(tr);
		}
		enableSorting('binsTable');
	}

	async function loadPrevActualMap(prevDate){
		const url = `${PRED_DIR}/comparison_table_${prevDate}.csv`;
		if (!(await headExists(url))) return new Map();
		const df = await loadCSV(url);
		const cols = {}; const lc={}; for (const c of df.meta.fields){ lc[c.toLowerCase()] = c; }
		const a1 = (Object.keys(lc).find(k=>k.includes('actual_t'))||Object.keys(lc).find(k=>k==='actual'));
		const a1c = lc[a1];
		const symKey = (Object.keys(df.data[0]||{}).find(k=>k.toLowerCase()==='symbol')||'Symbol');
		const m = new Map();
		for (const row of df.data){ const sym = String(row[symKey]||'').toUpperCase(); const v = toNum(row[a1c]); if (sym && Number.isFinite(v)) m.set(sym, v); }
		return m;
	}

	async function loadCertifiedIfAvailable(selectedDate){
		const url = `${APP_DATA_DIR}/certified_candidates_${selectedDate}.csv`;
		if (!(await headExists(url))) return null;
		const df = await loadCSV(url);
		const rows = [];
		// load name map from nearest comparison table
		let nameMap = new Map();
		try {
			let d = selectedDate;
			let found = null;
			for (let i=0;i<7;i++){
				const test = `${APP_DATA_DIR}/comparison_table_${d}.csv`;
				if (await headExists(test)) { found=test; break; }
				const dt = new Date(Number(d.slice(0,4)), Number(d.slice(4,6))-1, Number(d.slice(6,8))); dt.setDate(dt.getDate()-1); d = ymd(dt);
			}
			if (found){ const cdf = await loadCSV(found); const cols = mapColumns(cdf); if (cols.name){ for (const rr of cdf.data){ const sym = String(rr.Symbol||rr.symbol||'').toUpperCase(); const nm = rr[cols.name]; if (sym) nameMap.set(sym, nm); } } }
		} catch(e){}
		for (const r of df.data){
			const sym = String(r.symbol||r.Symbol||'').toUpperCase();
			const ratio = toNum(r.f10_over_c1_x);
			const f10 = toNum(r.f10_T);
			const a1p = toNum(r.a1_prev);
			const a1t = toNum(r.a1_T);
			const growth_t = toNum(r.f10_over_a1_T_x);
			const s7 = toNum(r.sentiment_7d);
			const sflag = String(r.sentiment7d_gt_0_2||'').toLowerCase();
			const sgt = (sflag==='true' || sflag==='1') ? 'Yes' : (sflag===''? '': 'No');
			const f10d = r.f10_date || '';
			const a1pd = r.a1_prev_date || '';
			if (!sym || !Number.isFinite(ratio)) continue;
			// Enforce |F10/C1| ≤ 2% in viewer to match spec
			if (!Number.isFinite(ratio) || Math.abs(ratio - 1.0) > 0.02) continue;
			// Compute growth from numeric F10 and A1_(T-1) to avoid misinterpreting percent vs ratio
			const growth = (Number.isFinite(f10) && Number.isFinite(a1p) && a1p>0) ? (f10 / a1p) : NaN;
			const growthNight = Number.isFinite(growth_t) ? growth_t : ((Number.isFinite(f10) && Number.isFinite(a1t) && a1t>0) ? (f10 / a1t) : NaN);
			rows.push({ sym, name: nameMap.get(sym)||'', ratio, growth, f10, a1p, f10d, a1pd, s7, sgt, a1t, growth_t: growthNight });
		}
		rows.sort((a,b)=> (isNaN(b.growth)?-1: b.growth) - (isNaN(a.growth)?-1: a.growth));
		return rows;
	}

	async function renderActionTable(selectedDate, df, cols){
		const tbody = document.querySelector('#actionTable tbody');
		tbody.innerHTML='';
		// Prefer precomputed certified file for the selected date
		let rows = await loadCertifiedIfAvailable(selectedDate);
		if (!rows){
			// Build previous date from comparison tables
		const ymdPrev = businessPrevYmd(selectedDate);
		const prevMap = await loadPrevActualMap(ymdPrev);
		for (const r of df.data){
			const sym = String(r.Symbol||r.symbol||r.SYMBOL||r.ticker||r.Ticker||'').toUpperCase();
			if (!sym) continue;
			const f10 = toNum(r[cols.f10]); const c1 = toNum(r[cols.c1]); if (!Number.isFinite(f10) || !Number.isFinite(c1) || c1<=0) continue;
			const ratio = f10 / c1; // certification check
			if (Math.abs(ratio - 1.0) > 0.02) continue; // <=2% only
			const prevA1 = prevMap.get(sym);
			const growth = (prevA1 && prevA1>0) ? (f10 / prevA1) : NaN; // F10_T / A1_(T-1)
			// Get A1_T from the same comparison file row if present
			let a1t = NaN;
			try {
				const rowMatch = df.data.find(x => (String(x.Symbol||x.symbol||'').toUpperCase()) === sym);
				// If df == comparison df, mapColumns will map a1; but in this branch df is comparison df
			} catch(e){}
			rows.push({ sym, ratio, growth, f10, a1p: prevA1, a1t: NaN, growth_t: NaN });
		}
		// sort by growth desc
        rows.sort((a,b)=> (isNaN(b.growth)?-1: b.growth) - (isNaN(a.growth)?-1: a.growth));
		}
    // Deduplicate by symbol to enforce primary key uniqueness
    const seen = new Set();
    const deduped = [];
    for (const r of rows){ if (r && r.sym && !seen.has(r.sym)){ seen.add(r.sym); deduped.push(r); } }
		// Render ALL certified (viewer can sort)
		let certified=0;
    for (const row of deduped){
			const tr = document.createElement('tr');
			const td0 = document.createElement('td'); td0.style.textAlign='left'; td0.textContent=row.sym; tr.appendChild(td0);
			const tdName = document.createElement('td'); tdName.style.textAlign='left'; tdName.textContent=row.name||''; tr.appendChild(tdName);
			const td1 = document.createElement('td'); td1.textContent=fmtPct(row.ratio); tr.appendChild(td1);
			const td2 = document.createElement('td'); td2.textContent=(Number.isFinite(row.f10)? row.f10.toFixed(2): 'N/A'); if (row.f10d) td2.title = `F10 date ${row.f10d}`; tr.appendChild(td2);
			const td3 = document.createElement('td'); td3.textContent=(Number.isFinite(row.a1p)? row.a1p.toFixed(2): 'N/A'); if (row.a1pd) td3.title = `A1 prev ${row.a1pd}`; tr.appendChild(td3);
			const td4 = document.createElement('td'); td4.textContent=(Number.isFinite(row.growth)? fmtPct(row.growth) : 'N/A'); tr.appendChild(td4);
			const tdS = document.createElement('td'); tdS.textContent=(Number.isFinite(row.s7)? row.s7.toFixed(2): (row.s7===''? '': 'N/A')); tr.appendChild(tdS);
			const tdSf = document.createElement('td'); tdSf.textContent=(row.sgt||''); tr.appendChild(tdSf);
			const td5 = document.createElement('td'); td5.textContent=(Number.isFinite(row.a1t)? row.a1t.toFixed(2): 'N/A'); tr.appendChild(td5);
			const td6 = document.createElement('td'); td6.textContent=(Number.isFinite(row.growth_t)? fmtPct(row.growth_t): 'N/A'); tr.appendChild(td6);
			tbody.appendChild(tr); certified++;
		}
		document.getElementById('certCount').textContent = `${certified} shown`;
		enableSorting('actionTable');
	}

	async function main(){
		statusLine.textContent = 'Discovering dates...';
		const hasStaging = await loadStagingMeta();
		let compDates = await discoverComparisonDates(60);
		if (hasStaging && STAGING.analysis_T) { compDates = [STAGING.analysis_T]; }
		const certDates = await discoverCertifiedDates(30);
		// Populate per-section selectors
		scatterDate.innerHTML = '';
		binsDateSelect.innerHTML = '';
		actionsDate.innerHTML = '';
		for (const d of compDates){ const opt=document.createElement('option'); opt.value=d; opt.textContent = `${d.slice(0,4)}-${d.slice(4,6)}-${d.slice(6,8)}`; scatterDate.appendChild(opt); }
		for (const d of compDates){ const opt=document.createElement('option'); opt.value=d; opt.textContent = `${d.slice(0,4)}-${d.slice(4,6)}-${d.slice(6,8)}`; binsDateSelect.appendChild(opt); }
		for (const d of certDates){ const opt=document.createElement('option'); opt.value=d; opt.textContent = `${d.slice(0,4)}-${d.slice(4,6)}-${d.slice(6,8)}`; actionsDate.appendChild(opt); }
		if (!compDates.length){ statusLine.textContent = 'No comparison tables found.'; return; }
		scatterDate.value = compDates[compDates.length-1];
		binsDateSelect.value = compDates[compDates.length-1];
		if (certDates.length) actionsDate.value = certDates[certDates.length-1];
		const binsFor = await loadBinsForDate(compDates, binsDateSelect.value);
		renderBinsTable(binsFor);
		// Last update sticker from meta
		try {
			const meta = await (await fetch(`${APP_DATA_DIR}/meta.json`)).json();
			if (meta && meta.last_update) {
				const sticker = document.createElement('span');
				sticker.className = 'small';
				sticker.textContent = `Last update: ${meta.last_update}${STAGING.active?' – STAGING':''}`;
				document.querySelector('.controls').appendChild(sticker);
			}
		} catch(e) {}
		statusLine.textContent = 'Ready.';
	}

	document.getElementById('applyBtn').addEventListener('click', async ()=>{
		const dTop = scatterDate.value; if (!dTop){ return; }
		const dBins = binsDateSelect.value || dTop;
		const dMorning = actionsDate.value || dTop;
		statusLine.textContent = `Loading T(scatter)=${dTop}, T(bins)=${dBins}, T+1(actions)=${dMorning}...`;
		let url = STAGING.active ? `${STAGING_DIR}/comparison_table_${dTop}_5.csv` : `${APP_DATA_DIR}/comparison_table_${dTop}.csv`;
		if (!(await headExists(url))) url = `${PRED_DIR}/comparison_table_${dTop}.csv`;
		try{
			const df = await loadCSV(url);
			const cols = mapColumns(df);
			if (!cols.f10 || !cols.c1 || !cols.a1){ statusLine.textContent = 'Required columns not found.'; return; }
			const filter = symbolFilter.value.trim();
			const filterSet = new Set((filter? filter.split(','):[]).map(s=>s.trim().toUpperCase()).filter(Boolean));
			const series = computeScatter(df, cols, filterSet);
			plotScatter(series);
			if (STAGING.active) {
				const tbody = document.querySelector('#actionTable tbody');
				tbody.innerHTML='';
				const urlCert = `${STAGING_DIR}/certified_candidates_${dMorning}_5.csv`;
				const sdf = await loadCSV(urlCert);
				let rows = [];
				for (const r of sdf.data){
					const sym = String(r.symbol||r.Symbol||'').toUpperCase();
					const ratio = toNum(r.f10_over_c1_x);
					const growth = toNum(r.f10_over_prev_a1_x);
					if (!sym || !Number.isFinite(ratio)) continue;
					rows.push({ sym, ratio, growth });
				}
				rows.sort((a,b)=> (isNaN(b.growth)?-1: b.growth) - (isNaN(a.growth)?-1: a.growth));
				let certified=0; for (const row of rows.slice(0,50)){
					const tr = document.createElement('tr');
					const td0 = document.createElement('td'); td0.style.textAlign='left'; td0.textContent=row.sym; tr.appendChild(td0);
					const td1 = document.createElement('td'); td1.textContent=(row.ratio).toFixed(3); tr.appendChild(td1);
					const td2 = document.createElement('td'); td2.textContent=(Number.isFinite(row.growth)? row.growth.toFixed(3): 'N/A'); tr.appendChild(td2);
					const td3 = document.createElement('td'); td3.textContent='N/A'; tr.appendChild(td3);
					tbody.appendChild(tr); certified++; }
				document.getElementById('certCount').textContent = `${certified} shown (top 50)`;
			} else {
				await renderActionTable(dMorning, df, cols);
			}
			const compDates = await discoverComparisonDates(60);
			const binsFor = await loadBinsForDate(compDates, dBins);
			renderBinsTable(binsFor);
			// update A1 prev date label
			const y=Number(dMorning.slice(0,4)), m=Number(dMorning.slice(4,6))-1, d=Number(dMorning.slice(6,8)); const dt=new Date(y,m,d); dt.setDate(dt.getDate()-1);
			const prev = `${dt.getFullYear()}-${String(dt.getMonth()+1).padStart(2,'0')}-${String(dt.getDate()).padStart(2,'0')}`;
			if (actionsPrevLabel) actionsPrevLabel.textContent = prev;
			statusLine.textContent = `Loaded T(scatter)=${dTop} (${series.text.length} pts), T(bins)=${dBins}, Actions T+1=${dMorning}.`;
		}catch(e){
			console.error(e); statusLine.textContent = 'Failed to load date.';
		}
	});

	main().then(()=>{ document.getElementById('applyBtn').click(); });
	</script>
</body>
</html>
