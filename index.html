<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1" />
	<title>E_LSTM_Forecasting – Daily Dashboard</title>
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
	<script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
	<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
	<style>
		:root { --bg:#0e1116; --card:#151a22; --muted:#8a94a6; --text:#e7ecf3; --accent:#2ea3f2; --ok:#18c49c; --warn:#ffba08; --bad:#ff5c5c; }
		html,body { height:100%; margin:0; font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji"; background:var(--bg); color:var(--text); }
		.container { max-width: 1400px; margin: 0 auto; padding: 16px 20px 32px; }
		h1 { font-size: 20px; margin: 0 0 10px; }
		.controls { display:flex; gap:12px; align-items:center; flex-wrap: wrap; margin-bottom: 14px; }
		select, input[type="text"] { background: var(--card); color: var(--text); border: 1px solid #2a3240; border-radius: 8px; padding: 8px 10px; }
		.grid { display:grid; grid-template-columns: 1fr 1fr; grid-auto-rows: minmax(320px, auto); gap: 16px; }
		.card { background: var(--card); border: 1px solid #1f2430; border-radius: 12px; padding: 12px; box-shadow: 0 0 0 1px rgba(255,255,255,0.02) inset; }
		.card h2 { font-size: 16px; margin: 0 0 8px; }
		.small { color: var(--muted); font-size: 12px; }
		.table { width: 100%; border-collapse: collapse; }
		.table th, .table td { border-bottom: 1px solid #222836; padding: 8px 10px; font-size: 13px; text-align: right; }
		.table th { color: var(--muted); font-weight: 600; text-transform: uppercase; letter-spacing: .02em; font-size: 12px; }
		.badge { display:inline-block; padding: 2px 6px; border-radius: 6px; font-size: 12px; }
		.badge.ok { background: rgba(24,196,156,.14); color: var(--ok); }
		.badge.warn { background: rgba(255,186,8,.14); color: var(--warn); }
		.badge.bad { background: rgba(255,92,92,.14); color: var(--bad); }
		.flex { display:flex; gap:10px; align-items:center; justify-content: space-between; }
		.kpi { font-weight: 700; }
		.footer { margin-top: 16px; color: var(--muted); font-size: 12px; }
		@media (max-width: 1100px) { .grid { grid-template-columns: 1fr; } }
	</style>
</head>
<body>
	<div class="container">
		<h1>Forecast10 Dashboard</h1>
		<div class="controls">
			<label>
				<span class="small">Filter symbol</span><br/>
				<input id="symbolFilter" type="text" placeholder="e.g. AAPL, MSFT (optional)" />
			</label>
			<button id="applyBtn">Apply</button>
			<span class="small" id="statusLine"></span><span class="small" id="qcR4a" style="margin-left:10px;"></span>
		</div>

		<div class="grid">
			<div class="card" style="grid-column:1/3;">
				<div class="flex"><h2>Certified candidates (F10/C1 ≤ 1.03)</h2><div class="small">T+1 <select id="actionsDate"></select> · uses A1_(T-1)=<span id="actionsPrevLabel"></span> · <span id="certCount"></span></div></div>
				<table class="table" id="actionTable">
					<thead><tr>
						<th style="text-align:left">Symbol</th>
						<th>F10/C1 (%)</th>
						<th>F10_T</th>
						<th>A1_(T-1)</th>
						<th>F10 / A1(T-1) (%)</th>
						<th>Sent7d</th>
						<th>Sent>0.2</th>
						<th>BB %b</th>
						<th>Pct>200d</th>
						<th>Rule</th>
						<th>Market</th>
						<th>R4a</th>
						<th>Stop</th>
					</tr></thead>
					<tbody></tbody>
				</table>
			</div>
		</div>

		<div class="footer">Data sources: comparison tables and bins under ../data/processed/predictions/. Degrades gracefully when files are not present.</div>
	</div>

	<script>
	// Configuration
	const PRED_DIR = './data/processed/predictions';
	const APP_DATA_DIR = './App/data'; // preferred local cache for dashboard
	const TECH_DIR = '../w_datalake/data/raw/technical'; // optional, may be missing
	const BINS = [0,2,5,10,20];
	const BIN_LABELS = ['<0%','0-2%','2-5%','5-10%','10-20%','>20%'];
    const STAGING_DIR = './data/staging'; // optional 5-stock staging
    const STAGING = { active:false, analysis_T:null, morning_Tp1:null, symbols:[] };
    let CURRENT = { actionsTp1:null };

    const actionsDate = document.getElementById('actionsDate');
    const symbolFilter = document.getElementById('symbolFilter');
    const statusLine = document.getElementById('statusLine');
    const actionsPrevLabel = document.getElementById('actionsPrevLabel');

	function ymd(date){ const y=date.getFullYear(); const m=String(date.getMonth()+1).padStart(2,'0'); const d=String(date.getDate()).padStart(2,'0'); return `${y}${m}${d}`; }
	function addDays(date, delta){ const d=new Date(date); d.setDate(d.getDate()+delta); return d; }
	function businessPrevYmd(yyyymmdd){
		const y = Number(yyyymmdd.slice(0,4)), m = Number(yyyymmdd.slice(4,6))-1, d = Number(yyyymmdd.slice(6,8));
		const dt = new Date(y,m,d);
		do { dt.setDate(dt.getDate()-1); } while (dt.getDay()===0 || dt.getDay()===6);
		return ymd(dt);
	}

	async function headExists(url){
		try {
			const sep = url.includes('?') ? '&' : '?';
			const res = await fetch(`${url}${sep}v=${Date.now()}`, {method:'GET'});
			return res.ok;
		} catch(e){ return false; }
	}

    async function loadStagingMeta(){
        try {
            const res = await fetch(`${STAGING_DIR}/meta.json`);
            if (!res.ok) return false;
            const meta = await res.json();
            STAGING.active = true;
            STAGING.analysis_T = String(meta.analysis_T || '');
            STAGING.morning_Tp1 = String(meta.morning_T || meta.morning_T_plus_1 || '');
            STAGING.symbols = meta.symbols || [];
            return true;
        } catch(e){ return false; }
    }

	async function discoverDates(maxBack=60){
		// Build a union of dates from: meta.latest_date, comparison tables, certified files
		const set = new Set();
		try { const meta = await (await fetch(`${APP_DATA_DIR}/meta.json`)).json(); if (meta && meta.latest_date) set.add(String(meta.latest_date)); } catch(e) {}
		// scan back for comparison tables
		const today = new Date();
		for (let i=0;i<maxBack;i++){
			const d = ymd(addDays(today, -i));
			if (await headExists(`${PRED_DIR}/comparison_table_${d}.csv`)) set.add(d);
		}
		// probe for certified files (morning output)
		for (let i=0;i<7;i++){
			const d = ymd(addDays(today, -i));
			if (await headExists(`${APP_DATA_DIR}/certified_candidates_${d}.csv`)) set.add(d);
		}
		return Array.from(set).sort();
	}

	async function discoverCertifiedDates(maxBack=30){
		const found = [];
		const today = new Date();
		for (let i=0;i<maxBack;i++){
			const d = ymd(addDays(today, -i));
			if (await headExists(`${APP_DATA_DIR}/certified_candidates_${d}.csv`)) found.push(d);
		}
		return found.reverse();
	}

	function mapColumns(df){
		const cols = {}; const lc = {};
		for (const c of df.meta.fields){ lc[c.toLowerCase()] = c; }
		const pick = (keys) => {
			for (const k of keys){ for (const key in lc){ if (key.includes(k)) return lc[key]; } }
			return null;
		};
		return {
			f10: pick(['forecast10_t','forecast10']),
			f1: pick(['forecast1_t','forecast1']),
			c1: pick(['consensus1_t','consensus1','consensus']),
			a1: pick(['actual_t','actual']),
			name: pick(['name','company','security'])
		};
	}

	async function loadCSV(url){
		const sep = url.includes('?') ? '&' : '?';
		const txt = await (await fetch(`${url}${sep}v=${Date.now()}`)).text();
		return await new Promise((resolve)=>{
			Papa.parse(txt, { header:true, dynamicTyping:true, skipEmptyLines:true, complete: (res)=> resolve(res) });
		});
	}

	function toNum(v){
		// Treat empty strings as NaN (Number('') === 0 is misleading for missing values)
		if (v === null || v === undefined) return NaN;
		const s = String(v).trim();
		if (!s) return NaN;
		const x = Number(s);
		return Number.isFinite(x) ? x : NaN;
	}
	function ratioToPct(r){ return Number.isFinite(r) ? (r-1)*100 : NaN; }
	function fmtPct(r, digits=1){ const v = ratioToPct(r); return Number.isFinite(v) ? `${v.toFixed(digits)}%` : 'N/A'; }
	function parseCellNumber(txt){ if (txt==null) return NaN; const s = String(txt).replace(/[%,$\s]/g,''); const n = Number(s); return Number.isFinite(n)? n : NaN; }

	function enableSorting(tableId){
		const table = document.getElementById(tableId);
		if (!table) return;
		const ths = table.querySelectorAll('thead th');
		ths.forEach((th, idx)=>{
			th.style.cursor = 'pointer';
			th.addEventListener('click', ()=>{
				const tbody = table.querySelector('tbody');
				const rows = Array.from(tbody.querySelectorAll('tr'));
            const dir = th.dataset.dir ? (th.dataset.dir === 'asc' ? 'desc' : 'asc') : 'asc';
				ths.forEach(h=> delete h.dataset.dir); th.dataset.dir = dir;
				rows.sort((a,b)=>{
					const av = a.children[idx]?.textContent || '';
					const bv = b.children[idx]?.textContent || '';
					const an = parseCellNumber(av), bn = parseCellNumber(bv);
					let cmp;
					if (Number.isFinite(an) && Number.isFinite(bn)) cmp = an - bn; else cmp = String(av).localeCompare(String(bv));
					return dir==='asc' ? cmp : -cmp;
				});
				rows.forEach(r=> tbody.appendChild(r));
			});
		});
	}

	function computeScatter(df, cols, filterSymbols){
		const x=[], y=[], text=[];
		for (const row of df.data){
			const sym = row.Symbol || row.symbol || row.SYMBOL || row.ticker || row.Ticker;
			if (filterSymbols && filterSymbols.size && (!sym || !filterSymbols.has(String(sym).toUpperCase()))) continue;
			const f10 = toNum(row[cols.f10]); const c1 = toNum(row[cols.c1]); const a1 = toNum(row[cols.a1]);
			if (!Number.isFinite(f10) || !Number.isFinite(c1) || !Number.isFinite(a1) || c1<=0 || a1<=0) continue;
			x.push(ratioToPct(f10 / c1));
			y.push(ratioToPct(f10 / a1));
			text.push(sym);
		}
		return {x,y,text};
	}

	function plotScatter(series){
    const minX = Math.min(...series.x, 0);
    const maxX = Math.max(...series.x, 0);
    const minY = Math.min(...series.y, 0);
    const maxY = Math.max(...series.y, 0);
    // Quadrant counts relative to axes (0,0)
    let q1=0,q2=0,q3=0,q4=0, onAxes=0;
    for (let i=0;i<series.x.length;i++){
        const xx = series.x[i]; const yy = series.y[i];
        if (xx===0 || yy===0) { onAxes++; continue; }
        if (xx>0 && yy>0) q1++; else if (xx<0 && yy>0) q2++; else if (xx<0 && yy<0) q3++; else if (xx>0 && yy<0) q4++;
    }
    const qc = document.getElementById('quadCounts');
    if (qc){ qc.textContent = `Q1(+/+)=${q1} · Q2(-/+)=${q2} · Q3(-/-)=${q3} · Q4(+/-)=${q4}${onAxes?` · on-axes=${onAxes}`:''}`; }
		const pad = 0.05;
		const layout = {
			margin:{l:40,r:10,t:10,b:40}, paper_bgcolor:'transparent', plot_bgcolor:'transparent',
			xaxis:{title:'F10_T / C1_T (%)', gridcolor:'#1f2430', zerolinecolor:'#2a3240', ticksuffix:'%', range:[minX*(1-pad), maxX*(1+pad)]},
			yaxis:{title:'F10_T / A1_T (%)', gridcolor:'#1f2430', zerolinecolor:'#2a3240', ticksuffix:'%', range:[minY*(1-pad), maxY*(1+pad)]},
			shapes:[
				{type:'line', x0:-5, x1:5, y0:0, y1:0, line:{color:'#444', width:1, dash:'dot'}},
				{type:'line', x0:0, x1:0, y0:-5, y1:5, line:{color:'#444', width:1, dash:'dot'}}
			],
			showlegend:false
		};
		const data = [{ type:'scattergl', mode:'markers', x:series.x, y:series.y, text:series.text, hovertemplate:'%{text}<br>x=%{x:.1f}%<br>y=%{y:.1f}%<extra></extra>', marker:{ color:'#2ea3f2', size:6, opacity:0.85 } }];
		Plotly.newPlot('scatter', data, layout, {displayModeBar:false, responsive:true});
	}

	async function loadBinsForDate(dateList, selected){
		// prefer the selected date; fall back to latest available
		const tryDates = [selected, ...dateList.slice().reverse()].filter(Boolean);
		for (const d of tryDates){
			const appUrl = `${APP_DATA_DIR}/bins_summary_${d}.csv`;
			if (await headExists(appUrl)) { const df = await loadCSV(appUrl); return { date:d, df }; }
			const url = `${PRED_DIR}/bins_summary_${d}.csv`;
			if (await headExists(url)) { const df = await loadCSV(url); return { date:d, df }; }
		}
		return null;
	}

	function mapBinsColumns(df){
		const lc = {}; for (const c of df.meta.fields){ lc[c.toLowerCase()] = c; }
		const binC = lc['bin'] || lc['bins'] || Object.values(lc).find(v=>/bin/i.test(v));
		const countC = lc['count'] || Object.values(lc).find(v=>/count/i.test(v));
		const meanC = Object.values(lc).find(v=>/mean.*f10.*a1|mean.*error|avg.*f10/i.test(v.toLowerCase())) || Object.values(lc).find(v=>/mean/i.test(v));
		const trendC = Object.values(lc).find(v=>/trend|7d/i.test(v.toLowerCase()));
		return { binC, countC, meanC, trendC };
	}

	function renderBinsTable(bins){
		const tbody = document.querySelector('#binsTable tbody');
		tbody.innerHTML = '';
		if (!bins || !bins.df || !bins.df.data || !bins.df.data.length){ binsDate.textContent=''; return; }
		const { binC, countC, meanC, trendC } = mapBinsColumns(bins.df);
		binsDate.textContent = `T=${bins.date.slice(0,4)}-${bins.date.slice(4,6)}-${bins.date.slice(6,8)}`;
		for (const r of bins.df.data){
			const tr = document.createElement('tr');
			const td0 = document.createElement('td'); td0.style.textAlign='left'; td0.textContent = r[binC]; tr.appendChild(td0);
			const td1 = document.createElement('td'); td1.textContent = toNum(r[countC])?.toLocaleString('en-US'); tr.appendChild(td1);
			const td2 = document.createElement('td'); td2.textContent = Number.isFinite(toNum(r[meanC])) ? `${toNum(r[meanC]).toFixed(1)}%` : 'N/A'; tr.appendChild(td2);
			const td3 = document.createElement('td'); td3.textContent = Number.isFinite(toNum(r[trendC])) ? `${toNum(r[trendC]).toFixed(1)}%` : 'N/A'; tr.appendChild(td3);
			tbody.appendChild(tr);
		}
		enableSorting('binsTable');
	}

	async function loadPrevActualMap(prevDate){
		// Prefer dedicated prev-actuals map written by the morning exporter; fallback to historical comparison if needed
		const appPrev = `${APP_DATA_DIR}/prev_actuals_${prevDate}.csv`;
		let df = null;
		if (await headExists(appPrev)) {
			df = await loadCSV(appPrev);
		} else {
			const url = `${APP_DATA_DIR}/comparison_table_${prevDate}.csv`;
			if (!(await headExists(url))) return new Map();
			df = await loadCSV(url);
		}
		const cols = {}; const lc={}; for (const c of df.meta.fields){ lc[c.toLowerCase()] = c; }
		const a1 = (Object.keys(lc).find(k=>k.includes('actual_t'))||Object.keys(lc).find(k==='actual'));
		const a1c = lc[a1];
		const symKey = (Object.keys(df.data[0]||{}).find(k=>k.toLowerCase()==='symbol')||'Symbol');
		const m = new Map();
		for (const row of df.data){ const sym = String(row[symKey]||'').toUpperCase(); const v = toNum(row[a1c]); if (sym && Number.isFinite(v)) m.set(sym, v); }
		return m;
	}

	async function loadCertifiedIfAvailable(selectedDate){
		const url = `${APP_DATA_DIR}/certified_candidates_${selectedDate}.csv`;
		if (!(await headExists(url))) return null;
		const df = await loadCSV(url);
		const rows = [];
		// optional name mapping skipped (column removed)
		for (const r of df.data){
			const sym = String(r.symbol||r.Symbol||'').toUpperCase();
			const ratio = toNum(r.f10_over_c1_x);
			const f10 = toNum(r.f10_T);
			const a1p = toNum(r.a1_prev);
			const a1t = NaN;
			const growth_t = NaN;
			const s7 = toNum(r.sentiment_7d);
			const sflag = String(r.sentiment7d_gt_0_2||'').toLowerCase();
			const sgt = (sflag==='true' || sflag==='1') ? 'Yes' : (sflag===''? '': 'No');
			const f10d = r.f10_date || '';
			const a1pd = r.a1_prev_date || '';
			const bb = toNum(r.bb_percent_b);
			const sma = toNum(r.pct_above_sma200);
			const spyBin = (r.spy_trend_bin===''||r.spy_trend_bin==null)? 'NA' : String(r.spy_trend_bin);
			const r4aFlag = String(r.rule_4a||'').toLowerCase();
			const r4a = (r4aFlag==='true' || r4aFlag==='1') ? 'Yes' : (r4aFlag===''? 'NA': 'No');
			const stop = toNum(r.stop_loss_pct);
			if (!sym || !Number.isFinite(ratio)) continue;
			// Enforce production certification rule F10/C1 ≤ 1.03
			if (!(ratio <= 1.03)) continue;
			// Compute growth from numeric F10 and A1_(T-1) to avoid misinterpreting percent vs ratio
			const growth = (Number.isFinite(f10) && Number.isFinite(a1p) && a1p>0) ? (f10 / a1p) : NaN;
			const growthNight = NaN;
			// Production Rule OK (legacy): F10/C1 ≤ 1.03 AND F10/A1_(T-1) ≥ 1.05 AND BB %b ≥ 0.60
			const ruleOK = (ratio <= 1.03) && (Number.isFinite(growth) && growth >= 1.05) && (Number.isFinite(bb) && bb >= 0.60);
			rows.push({ sym, ratio, growth, f10, a1p, f10d, a1pd, s7, sgt, bb, sma, ruleOK, spyBin, r4a, stop });
		}
		rows.sort((a,b)=> (isNaN(b.growth)?-1: b.growth) - (isNaN(a.growth)?-1: a.growth));
		return rows;
	}

	async function renderActionTable(selectedDate, df, cols){
		const tbody = document.querySelector('#actionTable tbody');
		tbody.innerHTML='';
		// Prefer precomputed certified file for the selected date
		let rows = await loadCertifiedIfAvailable(selectedDate);
		if (!rows){
			// Build previous date from comparison tables
		const ymdPrev = businessPrevYmd(selectedDate);
		const prevMap = await loadPrevActualMap(ymdPrev);
		for (const r of df.data){
			const sym = String(r.Symbol||r.symbol||r.SYMBOL||r.ticker||r.Ticker||'').toUpperCase();
			if (!sym) continue;
			const f10 = toNum(r[cols.f10]); const c1 = toNum(r[cols.c1]); if (!Number.isFinite(f10) || !Number.isFinite(c1) || c1<=0) continue;
			const ratio = f10 / c1; // certification check
			if (!(ratio <= 1.03)) continue; // new rule: <=1.03
			const prevA1 = prevMap.get(sym);
			const growth = (prevA1 && prevA1>0) ? (f10 / prevA1) : NaN; // F10_T / A1_(T-1)
			// Get A1_T from the same comparison file row if present
			let a1t = NaN;
			const ruleOK = (ratio <= 1.03) && (Number.isFinite(growth) && growth >= 1.05);
			rows.push({ sym, ratio, growth, f10, a1p: prevA1, bb: NaN, sma: NaN, ruleOK });
		}
		// sort by growth desc
        rows.sort((a,b)=> (isNaN(b.growth)?-1: b.growth) - (isNaN(a.growth)?-1: a.growth));
		}
    // Deduplicate by symbol to enforce primary key uniqueness
    const seen = new Set();
    const deduped = [];
    for (const r of rows){ if (r && r.sym && !seen.has(r.sym)){ seen.add(r.sym); deduped.push(r); } }
		// Render ALL certified (viewer can sort)
		let certified=0;
		let spyNonEmpty=0, r4aYes=0, r4aNo=0, r4aNA=0, stopNonEmpty=0;
    for (const row of deduped){
			const tr = document.createElement('tr');
			const td0 = document.createElement('td'); td0.style.textAlign='left'; td0.textContent=row.sym; tr.appendChild(td0);
			const td1 = document.createElement('td'); td1.textContent=fmtPct(row.ratio); tr.appendChild(td1);
			const td2 = document.createElement('td'); td2.textContent=(Number.isFinite(row.f10)? row.f10.toFixed(2): 'N/A'); if (row.f10d) td2.title = `F10 date ${row.f10d}`; tr.appendChild(td2);
			const td3 = document.createElement('td'); td3.textContent=(Number.isFinite(row.a1p)? row.a1p.toFixed(2): 'N/A'); if (row.a1pd) td3.title = `A1 prev ${row.a1pd}`; tr.appendChild(td3);
			const td4 = document.createElement('td'); td4.textContent=(Number.isFinite(row.growth)? fmtPct(row.growth) : 'N/A'); tr.appendChild(td4);
			const tdS = document.createElement('td'); tdS.textContent=(Number.isFinite(row.s7)? row.s7.toFixed(2): (row.s7===''? '': 'N/A')); tr.appendChild(tdS);
			const tdSf = document.createElement('td'); tdSf.textContent=(row.sgt||''); tr.appendChild(tdSf);
			const tdBB = document.createElement('td'); tdBB.textContent=(Number.isFinite(row.bb)? row.bb.toFixed(2): ''); tr.appendChild(tdBB);
			const tdSMA = document.createElement('td'); tdSMA.textContent=(Number.isFinite(row.sma)? (row.sma*100).toFixed(1)+'%': ''); tr.appendChild(tdSMA);
			const tdRule = document.createElement('td'); tdRule.innerHTML = row.ruleOK ? '<span class="badge ok">RuleOK</span>' : ''; tr.appendChild(tdRule);
			const tdM = document.createElement('td'); tdM.textContent = row.spyBin || 'NA'; tr.appendChild(tdM);
			const tdR4 = document.createElement('td'); tdR4.textContent = row.r4a || 'NA'; tr.appendChild(tdR4);
			const tdStop = document.createElement('td'); tdStop.textContent = Number.isFinite(row.stop)? `${(row.stop*100).toFixed(1)}%` : (row.stop===''? 'NA':''); tr.appendChild(tdStop);
			tbody.appendChild(tr); certified++;
			if (row.spyBin && row.spyBin!=='NA') spyNonEmpty++;
			if (row.r4a==='Yes') r4aYes++; else if (row.r4a==='No') r4aNo++; else r4aNA++;
			if (Number.isFinite(row.stop)) stopNonEmpty++;
		}
		document.getElementById('certCount').textContent = `${certified} shown`;
		const qc = document.getElementById('qcR4a');
		if (qc) qc.textContent = `Market non-empty=${spyNonEmpty} · R4a Yes=${r4aYes} No=${r4aNo} NA=${r4aNA} · Stops=${stopNonEmpty}`;
		enableSorting('actionTable');
	}

	async function main(){
		statusLine.textContent = 'Discovering certified dates...';
		const hasStaging = await loadStagingMeta();
		const certDates = await discoverCertifiedDates(30);
		actionsDate.innerHTML = '';
		for (const d of certDates){ const opt=document.createElement('option'); opt.value=d; opt.textContent = `${d.slice(0,4)}-${d.slice(4,6)}-${d.slice(6,8)}`; actionsDate.appendChild(opt); }
		if (!certDates.length){ statusLine.textContent = 'No certified data available.'; return; }
		if (certDates.length) actionsDate.value = certDates[certDates.length-1];
		// Last update sticker from meta
		try {
			const meta = await (await fetch(`${APP_DATA_DIR}/meta.json`)).json();
			if (meta && meta.last_update) {
				const sticker = document.createElement('span');
				sticker.className = 'small';
				sticker.textContent = `Last update: ${meta.last_update}${STAGING.active?' – STAGING':''} (certified-only)`;
				document.querySelector('.controls').appendChild(sticker);
			}
		} catch(e) {}
		statusLine.textContent = 'Ready (certified-only).';
	}

	document.getElementById('applyBtn').addEventListener('click', async ()=>{
		const dMorning = actionsDate.value;
		if (!dMorning){ statusLine.textContent = 'No certified date selected.'; return; }
		statusLine.textContent = `Loading certified T+1=${dMorning}...`;
		try{
			await renderActionTable(dMorning, { data:[] }, {});
			// update A1 prev date label
			const y=Number(dMorning.slice(0,4)), m=Number(dMorning.slice(4,6))-1, d=Number(dMorning.slice(6,8)); const dt=new Date(y,m,d); dt.setDate(dt.getDate()-1);
			const prev = `${dt.getFullYear()}-${String(dt.getMonth()+1).padStart(2,'0')}-${String(dt.getDate()).padStart(2,'0')}`;
			if (actionsPrevLabel) actionsPrevLabel.textContent = prev;
			statusLine.textContent = `Loaded Actions T+1=${dMorning}.`;
		}catch(e){
			console.error(e); statusLine.textContent = 'Failed to load certified data.';
		}
	});

	main().then(()=>{ document.getElementById('applyBtn').click(); });
	</script>
</body>
</html>
